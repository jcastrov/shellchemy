#!/usr/bin/env bash

print_format "ðŸ§ª `color_green shellchemy` $SHELLCHEMY_VERSION (`color_magenta $SYSTEM_NAME`)";

__shellchemy_commands_help_cmd() {
  print_info "$(cat <<EOF
usage: shellchemy [cd] [help] [install <version> [<path>]]
                    [restart] [update [<path>]] [version] [vsc]

Available commands:
    $(color_cyan cd)       Change directory to shellchemy
    $(color_cyan help)     Show shellchemy available commands
    $(color_cyan install)  Install a specific <version> of shellchemy to the current path
             (or to a specific <path>)
    $(color_cyan restart)  Apply changes made to files under shellchemy directory
    $(color_cyan update)   Update shellchemy to the latest version (or to a specific <path>)
    $(color_cyan version)  Show the current version of shellchemy
    $(color_cyan vsc)      Open shellchemy directory in Visual Studio Code and change directory
EOF
)"
}

shellchemy() {
  if [[ -z $1 ]]; then __shellchemy_commands_help_cmd;
  elif [[ $1 == "cd" ]]; then __shellchemy_cd_cmd;
  elif [[ $1 == "help" ]]; then __shellchemy_commands_help_cmd;
  elif [[ $1 == "install" ]]; then __shellchemy_install_cmd $2;
  elif [[ $1 == "release" ]]; then __shellchemy_release_cmd;
  elif [[ $1 == "restart" ]]; then __shellchemy_restart_cmd;
  elif [[ $1 == "update" ]]; then __shellchemy_update_cmd;
  elif [[ $1 == "version" || $1 == "--version" ]]; then echo "$SHELLCHEMY_VERSION";
  elif [[ $1 == "vsc" ]]; then vsc "$SHELLCHEMY_PATH"; __shellchemy_cd_cmd;
  else print_error "`color_red $1` is not a shellchemy command. See `color_cyan "shellchemy help"`."
  fi
}

__shellchemy_cd_cmd() {
  print_info "Changing directory to `color_cyan shellchemy`...";
  run_cmd "cd $SHELLCHEMY_PATH";
}

__shellchemy_install_cmd() {
  has_parameters $@ || return 1;
  local version_to_install="$1";
  local install_dir="$2";

  __validate_version_number "$version_to_install" || return 1;

  if ! gh release view "v$version_to_install" --repo "$repo" &>/dev/null; then
    print_error "Version '$version_to_install' does not exist"
    return 1
  fi

  __install_specific_version "$version_to_install" "$install_dir" || return 1;
}

__shellchemy_release_cmd() {
  is_git_directory "$SHELLCHEMY_PATH" || return 1;
  cmd_exists gh || return 1;

  local gh_auth_status=$(gh auth status 2>&1);
  if [[ $gh_auth_status =~ ^"You are not logged" ]]; then
    print_error "$gh_auth_status";
    return 1;
  fi

  # Ensure no uncommitted changes
  if ! git diff-index --quiet HEAD --; then
    question_warning "Are your sure you want to create a release with uncommitted changes?";
    [[ $? != 0 ]] && { print_ok "Release cancelled."; return 0; }
  fi

  # Get the current version if it was updated without restarting Shellchemy
  source "$SHELLCHEMY_PATH/variables";

  __validate_version_number "$SHELLCHEMY_VERSION" || return 1;

  print_info "Checking for latest release..."
  local latest_version="curl -s \"\$SHELLCHEMY_LATEST_RELEASE_URL\" | grep '\"tag_name\":' | cut -d '\"' -f 4 | sed 's/^v//'";
  print_cmd "$latest_version";
  latest_version=$(eval $latest_version);
  if [[ -z "$latest_version" ]]; then
    print_error "Could not find tag name with the latest version."
    return 1
  fi

  if [[ $SHELLCHEMY_VERSION == "$latest_version" ]]; then
    print_warning "Version `color_green $SHELLCHEMY_VERSION` is already released.";
    return 0;
  fi

  # Parse versions
  IFS='.' read -r cur_major cur_minor cur_patch <<< "$latest_version"
  IFS='.' read -r new_major new_minor new_patch <<< "$SHELLCHEMY_VERSION"

  # Validate sequential bump
  if ! (
    # patch bump
    { [[ $new_major -eq $cur_major ]] &&
      [[ $new_minor -eq $cur_minor ]] &&
      [[ $new_patch -eq $((cur_patch + 1)) ]]; } ||

    # minor bump
    { [[ $new_major -eq $cur_major ]] &&
      [[ $new_minor -eq $((cur_minor + 1)) ]] &&
      [[ $new_patch -eq 0 ]]; } ||

    # major bump
    { [[ $new_major -eq $((cur_major + 1)) ]] &&
      [[ $new_minor -eq 0 ]] &&
      [[ $new_patch -eq 0 ]]; }
  ); then
    print_warning "Invalid version bump:\n    - Latest version released: `color_green $latest_version`\n    - Version to release: `color_red $SHELLCHEMY_VERSION`."
    question_warning "Do you want to continue?";
    [[ $? != 0 ]] && { print_ok "Release cancelled."; return 0; }
  fi

  local tmp_dir=$(mktemp -d -t "shellchemy-release-XXXX");
  local tmp_zip="$tmp_dir/shellchemy.zip";

  print_info "Creating release package..."
  run_cmd "git archive --format zip  --prefix="shellchemy/" --output \"$tmp_zip\" HEAD"

  print_info "Creating GitHub release v$SHELLCHEMY_VERSION..."
  cmd=(gh release create "v$SHELLCHEMY_VERSION" "$tmp_zip" \
     --title "Shellchemy $SHELLCHEMY_VERSION")
  print_cmd "${cmd[@]}";
  if ! "${cmd[@]}"; then
    print_error "Failed to create release v$SHELLCHEMY_VERSION";
    rm -rf $tmp_dir;
    return 1;
  fi
  rm -rf $tmp_dir;

  print_ok "Release `color_cyan v$SHELLCHEMY_VERSION` created successfully!";
}

__shellchemy_restart_cmd() { 
  run_cmd ". $SHELLCHEMY_PATH/index";
}

__shellchemy_update_cmd() {
  print_info "Gettting latest version information from GitHub...";
  local release_json=$(run_cmd "curl -s $SHELLCHEMY_LATEST_RELEASE_URL");
  local version_to_install=$(echo "$release_json" | grep '"tag_name":' | cut -d '"' -f 4)
  if [[ -z "$version_to_install" ]]; then
    print_error "Could not find tag name with the latest version."
    return 1
  fi
 __install_specific_version "$version_to_install" "$1" || return 1;
}

__install_specific_version() {
  local version_to_install="$1";
  local install_dir="${2:-$SHELLCHEMY_PATH}";

  # Get the current version if it was updated without restarting Shellchemy
  source "$SHELLCHEMY_PATH/variables";

  if [[ "$version_to_install" == "$SHELLCHEMY_VERSION" ]]; then
    print_ok "shellchemy is already at the version `color_green $SHELLCHEMY_VERSION`.";
    return 0
  fi

  if [[ $(is_git_directory "$install_dir") -eq 0 ]]; then
    question_warning "`color_yellow $install_dir` is a git directory. Are you sure you want to continue?";
    [[ $? != 0 ]] && { print_ok "Action canceled."; return 1; }
  fi

  return 0;

  local zip_url="$SHELLCHEMY_RELEASES_URL/download/v$version_to_install/shellchemy.zip";

  question "Do you want to install the version `color_green $version_to_install`? (current: `color_red $SHELLCHEMY_VERSION`)";
  [[ $? != 0 ]] && { print_warning "Action canceled."; return 1; }

  # -d â†’ create a directory (not a file).
  # XXXXXX â†’ required pattern for mktemp; it gets replaced with random characters.
  local tmp_dir=$(mktemp -d /tmp/shellchemy.XXXXXX);
  print_info "Downloading zipped file...";

  # Download the release archive
  # -L : follow redirects (GitHub release URLs redirect to Amazon S3 storage)
  # -o : write output to a file instead of stdout
  run_cmd "curl -L \"$zip_url\" -o \"$tmp_dir/release.zip\""

  print_info "Extracting..."
  # Unzip the archive into the temporary directory
  # -q : quiet mode (suppress most output)
  # -o : overwrite existing files without prompting
  # -d : extract into the specified directory
  run_cmd "unzip -q -o \"$tmp_dir/release.zip\" -d \"$tmp_dir\""

  # Remove the archive after extraction to save space
  rm "$tmp_dir/release.zip"

  print_info "Installing to $install_dir..."
  # Sync extracted files into the install directory
  # -a      : "archive" mode (recursive copy, preserve symlinks, permissions, timestamps)
  # --delete: remove files in the destination that donâ€™t exist in the source
  rsync -a --delete "$tmp_dir"/*/ "$install_dir"

  print_info "Removing temporary directory";
  run_cmd "rm -rf $tmp_dir"

  __shellchemy_restart_cmd;
}

__validate_version_number() {
  if [[ ! $1 =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
    print_error "Version number must be in the format X.Y.Z (e.g., 1.2.3)";
    return 1;
  fi
  return 0;
}