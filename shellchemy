#!/usr/bin/env bash
SHELLCHEMY_VERSION="v1.0.0";

echo "ðŸ§ª `color_green shellchemy` $SHELLCHEMY_VERSION (`color_magenta $SYSTEM_NAME`)";

shellchemy() {
  if [[ -z $1 || $1 == "help" ]]; then
    print_info "$(cat <<EOF
usage: shellchemy [cd] [restart] [update] [version] [vsc]
    $(color_cyan cd)       Change directory to shellchemy
    $(color_cyan help)     Show shellchemy available commands
    $(color_cyan restart)  Apply changes made to files under shellchemy directory
    $(color_cyan update)   Pull new changes and restart shellchemy
    $(color_cyan version)  Shows the current version of shellchemy
    $(color_cyan vsc)      Open shellchemy directory in Visual Studio Code and change directory
EOF
)"
  elif [[ $1 == "cd" ]]; then
    __shellchemy_cd;
  elif [[ $1 == "restart" ]]; then
    __shellchemy_restart;
  elif [[ $1 == "update" ]]; then
    __shellchemy_update;
    # print_info "Updating shellchemy...";
    # local current_path=$PWD;
    # __shellchemy_cd && run_cmd "$git_switch main" && gitpl && __shellchemy_restart;
    # run_cmd "cd $current_path";
  elif [[ $1 == "version" || $1 == "--version" ]]; then
    echo "$SHELLCHEMY_VERSION";
  elif [[ $1 == "vsc" ]]; then
    vsc "$shellchemy_path";
    __shellchemy_cd;
  else
    print_error "`color_red $1` is not a shellchemy command. See `color_cyan "shellchemy help"`."
  fi
}

__shellchemy_cd() {
  print_info "Changing directory to `color_cyan shellchemy`...";
  run_cmd "cd $shellchemy_path";
}
__shellchemy_restart() { 
  print_info "Restarting shellchemy...";
  run_cmd ". $shellchemy_path/index";
}

__shellchemy_update() {
  # local repo="jcastrov/shellchemy"
  local repo="xivdev/Penumbra"
  local install_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

  print_info "Checking for latest release..."
  local release_json=$(run_cmd2 "curl -s https://api.github.com/repos/$repo/releases/latest");
  local latest_version=$(echo "$release_json" | grep '"tag_name":' | cut -d '"' -f 4)
  if [[ -z "$latest_version" ]]; then
    print_error "Could not find tag name."
    return 1
  fi
  if [[ "$latest_version" == "$SHELLCHEMY_VERSION" ]]; then
    print_ok "shellchemy is already up-to-date (version `color_green $SHELLCHEMY_VERSION`)"
    return 0
  fi
  local zip_url=$(echo "$release_json" | grep "browser_download_url.*zip" | cut -d '"' -f 4);
  if [[ -z "$zip_url" ]]; then
    print_error "Could not find release download URL."
    return 1
  fi

  # print_info "New version available: `color_green $latest_version` (current: `color_red $SHELLCHEMY_VERSION`)"
  question "New version available: `color_green $latest_version` (current: `color_red $SHELLCHEMY_VERSION`). Do you want to continue?";
  [[ $? != 0 ]] && { print_warning "Update cancelled."; return 1; }

  # -d â†’ create a directory (not a file).
  # XXXXXX â†’ required pattern for mktemp; it gets replaced with random characters.
  local tmp_dir=$(mktemp -d /tmp/shellchemy.XXXXXX);
  print_info "Using temporary directory: $tmp_dir";

  # Download the release archive
  # -L : follow redirects (GitHub release URLs redirect to Amazon S3 storage)
  # -o : write output to a file instead of stdout
  run_cmd2 "curl -L \"$zip_url\" -o \"$tmp_dir/release.zip\""

  print_info "Extracting..."
  # Unzip the archive into the temporary directory
  # -q : quiet mode (suppress most output)
  # -o : overwrite existing files without prompting
  # -d : extract into the specified directory
  run_cmd2 "unzip -q -o \"$tmp_dir/release.zip\" -d \"$tmp_dir\""

  # Remove the archive after extraction to save space
  rm "$tmp_dir/release.zip"

  echo "ðŸ“‚ Installing to $install_dir..."
  # Sync extracted files into the install directory
  # -a      : "archive" mode (recursive copy, preserve symlinks, permissions, timestamps)
  # --delete: remove files in the destination that donâ€™t exist in the source
  # rsync -a --delete "$tmp_dir"/*/ "$install_dir"

  # rm -rf "$tmp_dir"

  echo "âœ… Updated from $SHELLCHEMY_VERSION â†’ $latest_version"
}

