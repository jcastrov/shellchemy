#!/usr/bin/env bash
SHELLCHEMY_VERSION="1.1.0";
SHELLCHEMY_REPO="jcastrov/shellchemy";
SHELLCHEMY_LATEST_RELEASE_URL="https://api.github.com/repos/$SHELLCHEMY_REPO/releases/latest";

print -P "ðŸ§ª `color_green shellchemy` $SHELLCHEMY_VERSION (`color_magenta $SYSTEM_NAME`)";

shellchemy() {
  if [[ -z $1 || $1 == "help" ]]; then
    print_info "$(cat <<EOF
usage: shellchemy [cd] [restart] [update] [version] [vsc]
    $(color_cyan cd)       Change directory to shellchemy
    $(color_cyan help)     Show shellchemy available commands
    $(color_cyan restart)  Apply changes made to files under shellchemy directory
    $(color_cyan update)   Pull new changes and restart shellchemy
    $(color_cyan version)  Shows the current version of shellchemy
    $(color_cyan vsc)      Open shellchemy directory in Visual Studio Code and change directory
EOF
)"
  elif [[ $1 == "cd" ]]; then
    __shellchemy_cd;
  elif [[ $1 == "release" ]]; then
    __shellchemy_release;
  elif [[ $1 == "restart" ]]; then
    __shellchemy_restart;
  elif [[ $1 == "update" ]]; then
    __shellchemy_update;
  elif [[ $1 == "version" || $1 == "--version" ]]; then
    echo "$SHELLCHEMY_VERSION";
  elif [[ $1 == "vsc" ]]; then
    vsc "$SHELLCHEMY_PATH"; __shellchemy_cd;
  else
    print_error "`color_red $1` is not a shellchemy command. See `color_cyan "shellchemy help"`."
  fi
}

__shellchemy_cd() {
  print_info "Changing directory to `color_cyan shellchemy`...";
  run_cmd "cd $SHELLCHEMY_PATH";
}

__shellchemy_release() {
  is_git_directory "$SHELLCHEMY_PATH" || return 1;
  cmd_exists gh || return 1;

  local gh_auth_status=$(gh auth status 2>&1);
  if [[ $gh_auth_status =~ ^"You are not logged" ]]; then
    print_error "$gh_auth_status";
    return 1;
  fi

  # Ensure no uncommitted changes
  if ! git diff-index --quiet HEAD --; then
    print_error "Be sure to commit all your changes before creating a release.";
    return 1
  fi

  if [[ ! $SHELLCHEMY_VERSION =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
    print_error "\$SHELLCHEMY_VERSION variable must be in the format X.Y.Z (e.g., 1.2.3)";
    return 1;
  fi

  print_info "Checking for latest release..."
  local latest_version=$(run_cmd "curl -s $SHELLCHEMY_LATEST_RELEASE_URL | grep '\"tag_name\":' | cut -d '\"' -f 4 | sed 's/^v//'");
  if [[ -z "$latest_version" ]]; then
    print_error "Could not find tag name with the latest version."
    return 1
  fi

  if [[ $SHELLCHEMY_VERSION == "$latest_version" ]]; then
    print_warning "Version `color_green $SHELLCHEMY_VERSION` is already released.";
    return 0;
  fi

  # Parse versions
  IFS='.' read -r cur_major cur_minor cur_patch <<< "$latest_version"
  IFS='.' read -r new_major new_minor new_patch <<< "$SHELLCHEMY_VERSION"

  # Validate sequential bump
  if ! (
    # patch bump
    { [[ $new_major -eq $cur_major ]] &&
      [[ $new_minor -eq $cur_minor ]] &&
      [[ $new_patch -eq $((cur_patch + 1)) ]]; } ||

    # minor bump
    { [[ $new_major -eq $cur_major ]] &&
      [[ $new_minor -eq $((cur_minor + 1)) ]] &&
      [[ $new_patch -eq 0 ]]; } ||

    # major bump
    { [[ $new_major -eq $((cur_major + 1)) ]] &&
      [[ $new_minor -eq 0 ]] &&
      [[ $new_patch -eq 0 ]]; }
  ); then
    print_warning "Invalid version bump:\n    - Latest version released: `color_green $latest_version`\n    - Version to release: `color_red $SHELLCHEMY_VERSION`."
    question_warning "Do you want to continue?";
    [[ $? != 0 ]] && { print_ok "Release cancelled."; return 0; }
  fi

  local tmp_dir=$(mktemp -d -t "shellchemy-release-XXXX");
  local tmp_zip="$tmp_dir/shellchemy.zip";

  print_info "Creating release package..."
  run_cmd "git archive --format zip  --prefix="shellchemy/" --output \"$tmp_zip\" HEAD"

  print_info "Creating GitHub release v$SHELLCHEMY_VERSION..."
  cmd=(gh release create "v$SHELLCHEMY_VERSION" "$tmp_zip" \
     --title "Shellchemy $SHELLCHEMY_VERSION")
  print_cmd "${cmd[@]}";
  if ! "${cmd[@]}"; then
    print_error "Failed to create release v$SHELLCHEMY_VERSION";
    rm -rf $tmp_dir;
    return 1;
  fi
  rm -rf $tmp_dir;

  print_ok "Release `color_cyan v$SHELLCHEMY_VERSION` created successfully!";
}

__shellchemy_restart() { 
  run_cmd ". $SHELLCHEMY_PATH/index";
}

__shellchemy_update() {
  local install_dir="${1:-$SHELLCHEMY_PATH}";
  if [[ $(is_git_directory "$install_dir") -eq 0 ]]; then
    question_warning "`color_yellow $install_dir` is a git directory. Are you sure you want to continue?";
    [[ $? != 0 ]] && { print_ok "Update cancelled."; return 1; }
  fi

  print_info "Gettting latest version information from GitHub...";
  local release_json=$(run_cmd "curl -s $SHELLCHEMY_LATEST_RELEASE_URL");
  local latest_version=$(echo "$release_json" | grep '"tag_name":' | cut -d '"' -f 4)
  if [[ -z "$latest_version" ]]; then
    print_error "Could not find tag name with the latest version."
    return 1
  fi
  if [[ "$latest_version" == "$SHELLCHEMY_VERSION" ]]; then
    print_ok "shellchemy is already up-to-date (version `color_green $SHELLCHEMY_VERSION`)"
    return 0
  fi
  local zip_url=$(echo "$release_json" | grep "browser_download_url.*zip" | cut -d '"' -f 4);
  if [[ -z "$zip_url" ]]; then
    print_error "Could not find release download URL."
    return 1
  fi

  # print_info "New version available: `color_green $latest_version` (current: `color_red $SHELLCHEMY_VERSION`)"
  question "New version available: `color_green $latest_version` (current: `color_red $SHELLCHEMY_VERSION`). Do you want to continue?";
  [[ $? != 0 ]] && { print_warning "Update cancelled."; return 1; }

  # -d â†’ create a directory (not a file).
  # XXXXXX â†’ required pattern for mktemp; it gets replaced with random characters.
  local tmp_dir=$(mktemp -d /tmp/shellchemy.XXXXXX);
  print_info "Downloading zipped file...";

  # Download the release archive
  # -L : follow redirects (GitHub release URLs redirect to Amazon S3 storage)
  # -o : write output to a file instead of stdout
  run_cmd "curl -L \"$zip_url\" -o \"$tmp_dir/release.zip\""

  print_info "Extracting..."
  # Unzip the archive into the temporary directory
  # -q : quiet mode (suppress most output)
  # -o : overwrite existing files without prompting
  # -d : extract into the specified directory
  run_cmd "unzip -q -o \"$tmp_dir/release.zip\" -d \"$tmp_dir\""

  # Remove the archive after extraction to save space
  rm "$tmp_dir/release.zip"

  print_info "Installing to $install_dir..."
  # Sync extracted files into the install directory
  # -a      : "archive" mode (recursive copy, preserve symlinks, permissions, timestamps)
  # --delete: remove files in the destination that donâ€™t exist in the source
  rsync -a --delete "$tmp_dir"/*/ "$install_dir"

  print_info "Removing temporary directory";
  run_cmd "rm -rf $tmp_dir"

  __shellchemy_restart;
}

