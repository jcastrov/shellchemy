#!/usr/bin/env bash

# Adds files and shows a quick status
gita() {
  has_parameters $@ || return 1;
  run_cmd "git add $1";
  run_cmd "git status -s"
}

# Deletes a branch locally
gitbD() {
  local branch_to_delete=$1;
  local current_branch="";
  [ $# == 0 ] && { 
    current_branch=$(echo_current_branch);
    branch_to_delete=$current_branch;
  }
  branch_locally_exists $branch_to_delete || return 1;
  question "Are you sure to force delete `color_red $branch_to_delete` locally?"
  [ $? != 0 ] && return 0;

  if [[ $current_branch == $branch_to_delete ]]; then
    get_main_branch "main_branch";
    print_info "Switching to `color_cyan $main_branch` branch";
    run_cmd "$git_switch $main_branch";
  fi
  print_ok "Deleting branch `color_red $branch_to_delete`..."
  run_cmd "git branch -D $branch_to_delete";
}

# Gets the list of branches created in remote
#    $@: Additional parameters
gitbl() {
  run_cmd "git for-each-ref --sort=authorname --format='%(committerdate) %09 %(authorname) %09 %(refname)' refs/remotes $@"
}

# Renames a branch
#    $@: Branch name and additional parameters
gitbm() { run_cmd "git branch -m $@"; }

# Commits your changes
#    $1: Summary.
#    $2 (optional): Description.
gitc() {
  has_parameters $@ || return 1;
  local current_branch=$(echo_current_branch);
  print_info "Committing your changes.";
  run_cmd "git commit -m \"$current_branch: $1\" $2";
}
gitca() { gitc "$1" "--amend"; }

gitchk() { run_cmd "git checkout $@"; }

# Cherry pick commands
gitchp() { run_cmd "git cherry-pick $1"; }
gitchpa() { run_cmd "git cherry-pick --abort"; }
gitchpc() { run_cmd "git cherry-pick --continue"; }

# Fetches branches
gitf() { 
  print_info "Downloading objects and refs from origin..."
  run_cmd "git fetch -p";
}

# Merge commands
gitm() { run_cmd "git merge $1"; }
gitma() { run_cmd "git merge --abort"; }
gitmc() { run_cmd "git merge --continue"; }
gitmo() { run_cmd "git merge $2 origin/$1 --no-edit"; }

# Opens remote on the browser with the current branch or a specific one ($1),
# optionally opening a specific file ($2).
#     $1 (optional): Branch name
#     $2 (optional): Relative path of the file
gito() {
  is_git_directory && local branch=$1 || return 1;
  [ -z "$1" ] && get_current_branch branch;
  [ -n "$2" ] && { gitof $2 $1; return 0; }
  print_info "Opening `color_cyan $branch` on remote...";
  run_cmd "open `get_repo_url`/tree/$branch";
}

# Opens a specific file on remote for the current branch. If $2 is specified,
# $2 will be the selected branch.
#     $1: Relative path of the file
#     $2 (Optional): Branch name 
gitof() {
  is_git_directory && has_parameters $@ && local branch=$2 || return 1;
  [ -z "$2" ] && get_current_branch branch;
  print_info "Opening file in `color_cyan $branch` on remote...";
  run_cmd "open `get_repo_url`/blob/$branch/$1";
}

# Pull commands
gitpl() { run_cmd "git pull"; }
gitplr() { run_cmd "git pull -r"; }

# Searches for pull requests on the repo URL, where the source branch is the
# current branch. If #1 is specified, $1 will be the search text.
#     $1 (Optional): Search text
gitprf() {
  is_git_directory || return 1;
  local search_text=$1;
  [ -z "$1" ] && { 
    get_current_branch current_branch;
    search_text="head:$current_branch";
  }
  run_cmd "open `get_repo_url`/pulls?q=$search_text"
}

# Pushes a branch
gitps() { 
  run_cmd "git push $@";
  [ $? != 0 ] && { return $?; }
  local current_branch=$(echo_current_branch);

  # If the branch ends with "-develop" or "-qa"
  if [[ $current_branch =~ -(develop|qa)$ ]]; then
    ##*- Remove the branch name. ABC-123-qa -> qa
    local base_branch="${current_branch##*-}";
  
    # %-* Remove the suffix. ABC-123-qa -> ABC-123
    local target_branch="${current_branch%-*}";

    question "Do you want to create a Pull Request (head: $(color_cyan $current_branch). base: $(color_magenta $base_branch))?";
    [ $? == 0 ] && { run_cmd "gitprc $base_branch"; }

    question "Do you want to switch back to branch $(color_cyan $target_branch)?";
    [ $? == 0 ] && { run_cmd "$git_switch $target_branch"; }
  fi
}

# Deletes a branch on remote.
#     $1: Branch name
gitpsd() {
  is_git_directory || return 1;
  local branch_to_delete=$1;
  [ $# == 0 ] && branch_to_delete=$(echo_current_branch);
  branch_on_remote_exists $branch_to_delete && {
    question "Do you want to delete `color_red $branch_to_delete` `color_yellow "on remote"`?";
    [ $? == 0 ] && { 
      run_cmd "git push origin --delete $branch_to_delete";
      run_cmd "git branch --unset-upstream $branch_to_delete";
    }
  }
}

# Pushes a branch forcefully
gitpsf() { gitps "--force-with-lease"; }

# Pushes a branch forcefully fixing the upstream
gitpsfu() { gitpsu "--force-with-lease"; }

# Renames the current branch locally and on remote.
#     $1: New branch name
gitpsm() {
  is_git_directory || return 1;
  get_current_branch current_branch;
  branch_on_remote_exists $current_branch || return 1;
  question "Are you sure to change the name from `color_red $current_branch` to `color_green $1`?"
  [ $? != 0 ] && return 0;
  run_cmd "git branch -m $1" &&
  run_cmd "git push origin :$current_branch $1" &&
  run_cmd "git push origin --set-upstream $1";
}

# Pushes a branch for the first time
gitpsu() { gitps "--set-upstream origin $(echo_current_branch) $@"; }

# Rebase commands
gitrb() { run_cmd "git rebase $@"; }
gitrbm() { gitrb origin/master; }
gitrba() { gitrb --abort; }
gitrbc() { gitrb --continue; }
gitrbi() { gitrb "-i $@"; }
gitrbih() { gitrbi HEAD~$1; }
gitrbio() { gitrbi origin/$1; }
gitrbq() { gitrb --quit; }
gitrbs() { gitrb --skip; }

# Reset commands
gitrm() { run_cmd "git reset --merge"; }
gitrs() { run_cmd "git reset $@"; }
gitrsh() { run_cmd "git reset --hard $1"; }
gitrsho() { run_cmd "git reset --hard origin/$1"; }

# Restore command
gitrt() {
  [[ $1 != "." ]] && run_cmd "$git_restore $@" && return 0;
  __option "Are you sure to restore all your modified files?"
  [ $? == 0 ] && __run "$git_restore_f";
}

# Status commands
gits() { run_cmd "git status"; }
gitss() { run_cmd "git status -s"; }

# Stash commands
gitsh() { run_cmd "git stash $@"; }
gitsha() { run_cmd "git stash apply"; }
gitshas() { run_cmd "git stash apply stash@{\"$1\"}"; }
gitshcl() { run_cmd "git stash clear"; }
gitshl() { run_cmd "git stash list"; }
gitshp() { run_cmd "git stash pop"; }
gitshps() { run_cmd "git stash save \"$1\""; }
gitshu() { run_cmd "git stash --include-untracked \"$1\""; }

# Switches or creates a branch from the current branch. Branch $1 will be
# created from $2 instead, if $2 is specified and $1 doesn't exist.
#     $1: Branch to switch or create
#     $2 (Optional): Branch or SHA starting point
gitsw() {
  has_parameters $@ || return 1;
  [ "$1" == "-" ] && {
    run_cmd "$git_switch -";
    return 0;
  }

  local start_point=$2;
  if [ -z "$2" ]; then
    start_point=$(echo_current_branch);
    branch_locally_exists $1 && { run_cmd "$git_switch $1"; return 0; }
  fi

  local on_remote=false;
  branch_on_remote_exists $1 && {
    on_remote=true;
    question "Do you want to switch to `color_yellow $1` remote branch?";
    [ $? == 0 ] && {
      gitf;
      run_cmd "$git_switch $1";
      return 0;
    }
  }

  if [[ $start_point =~ ^origin/ ]]; then
    ! branch_on_remote_exists ${2#"origin/"} && return 1;
  else
    question "Do you want to create `color_green $1` branch from local $(color_red $start_point)?";
    [ $? == 0 ] && {
      $on_remote && gitpsd $1;
      run_cmd "$git_switch_c $1 $start_point";
      return 0;
    };
    start_point="origin/$start_point";
  fi

  question "Do you want to create `color_green $1` branch from remote $(color_cyan $start_point)?";
  [ $? == 0 ] && {
    $on_remote && gitpsd $1;
    gitf;
    run_cmd "$git_switch_c $1 $start_point";
  }
  
  return 0;
}
gitswC() { run_cmd "git switch -C $@"; }

gitsync() {
  local current_branch=$(echo_current_branch);

  # Sync should not be done from qa or develop branches.
  if [[ $current_branch == "qa" || $current_branch == "develop" || $current_branch == "dev" ]]; then
    print_error "Current branch cannot be `color_cyan $current_branch`"; return 1;
  fi

  # If branch on remote doesn't exist, stop execution. Otherwise fetch remote branches.
  ! branch_on_remote_exists $1 && return 1;
  gitf;

  local new_branch=${current_branch}-$1;

  local switch_cmd="$git_switch_c $new_branch origin/$1";
  # Verify whether the new branch exists or needs to be recreated.
  if branch_on_remote_exists $new_branch && branch_locally_exists $new_branch; then
    question "Do you want to update the current `color_cyan $new_branch` branch?";
    [ $? == 0 ] && { switch_cmd="$git_switch $new_branch"; }
  fi
  run_cmd "$switch_cmd";

  question "Do you want to merge `color_cyan $new_branch` branch with the main branch using \"ours\" strategy?";
  [ $? == 0 ] && {
    get_main_branch "main_branch";
    gitmo $main_branch "-s ours"; 
    if [[ $current_branch == $main_branch ]]; then
      return 0;
    fi
  }

  gitmo $current_branch;
}

# Checks if the current directory or a specific one is inside a Git repostory.
#     $1 (optional): Directory path to validate
is_git_directory() {
  (cd ${1:-.}; [[ $(eval "git rev-parse --is-inside-work-tree") == "true" ]] && return 0 || return 1);
  return $?;
}
